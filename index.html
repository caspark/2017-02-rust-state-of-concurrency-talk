<!DOCTYPE html>
<html>
  <head>
    <title>Rust Concurrency for C++ Developers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      @page {
        size: 1210px 681px;
        margin: 0;
      }

      @media print {
        .remark-slide-scaler {
          width: 100% !important;
          height: 100% !important;
          transform: scale(1) !important;
          top: 0 !important;
          left: 0 !important;
        }
      }

      .quote { font-size: 200%; }
    </style>
    <script>
      // insert live reload script and remark's script
      if (location.host == '') {
        console.debug("Serving from filesystem - expecting live reload server to run on localhost:35729")
        // using embedded version of remark doesn't place nice with live reload for some reason
        document.write('<script src="http://localhost:35729/livereload.js?snipver=1"></' + 'script>');
        document.write('<script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></' + 'script>')
      } else {
        console.debug("Inserting embedded version of Remark into page...");
        // TODO re-insert embedded version of remark
        console.debug("Done inserting Remark. Presentation should be visible now.")
      }
    </script>
  </head>
  <body onload="var slideshow = remark.create({highlightStyle: 'monokai'}); document.getElementById('loading-text').style.display = 'none';">
    <div id="loading-text">
      <h1>Loading...</h1>
        If this text doesn't disappear after a few seconds, then <a href="https://github.com/gnab/remark/">Remark</a> is probably broken (it's supposed to load and turn this page into a presentation).
        <p>
        In that case, you can view the raw markdown source of the presentation slides by inspecting the source or by expanding the textarea below.
    </div>
    <textarea id="source" style="width: 100%; height: 800px;">
class: center, middle

# State of Concurrency in Rust

<sub>(Press P for slide notes.)</sub>

???

Notes on this presentation:

* Use arrow keys or scroll wheel to move through the slides
* Press ? for a full list of shortcuts
* Created using [Remark](https://github.com/gnab/remark/)

---

class: center, middle

# hi!

???

I'm Caspar, like the friendly ghost

---

class: center, middle

# You've probably heard...

### "Fearless concurrency with Rust"

???

E.g. https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html published a year ago

But why is that?

I hope to give you an intuitive understanding of Rust's concurrency options

---

# Agenda

1. Ownership & the Copy trait

2. Borrowing & the borrow checker

3. Threads & data race protection

4. Channels

6. Locks

7. Send & Sync

8. Parallel iterators via Rayon

9. Futures, Streams, Tokio 

???

# Assumed knowledge

* Basic Rust syntax - how to define variables, functions and structs

* `unsafe {}` exists

* What traits are & roughly how they work

---

# Ownership

* Each piece of data is owned by another piece of memory

* An owner is responsible for deallocating owned resources (e.g. memory)

* Ownership forms a directed acyclic graph rooted in `main()`'s stack

* Can only mutate data via a variable that owns that data

???

Hard to try Rust without coming across this so let's recap ownership & borrowing very quickly

Need to be on same page to understand what follows

---

# For example...

```rust
struct Starscape {
    stars: Vec<Star>,
    cat: NyanCat,
}

struct NyanCat {
    pos: (i32, i32),
    volume: u64,
}

fn main() {
    let universe: Starscape = unimplemented!(); // somehow make a Starscape
}
```

Just before `main()` completes, ownership looks like:

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="571px" height="121px" version="1.1" content="&lt;mxfile userAgent=&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&quot; version=&quot;6.2.1&quot; editor=&quot;www.draw.io&quot;&gt;&lt;diagram name=&quot;Page-1&quot;&gt;3VhNc5swEP01zCQXBiRCnGPiJO2h7XTGM216VEAGNQIxQsSmv74LiC8Lt05iOxn7YumxrLRvl7cCC8+T9SdJsvirCCm3kBOuLXxrIeQ67hX8VUjZIrNZg0SShRrrgQX7Q1tDjRYspPnIUAnBFcvGYCDSlAZqhBEpxWpsthR8vGpGImoAi4BwE/3JQhU36Az5Pf6ZsihuV3Z9HfEjCZ4iKYpUr2chvKx/zeWEtL50oHlMQrEaQPjOwnMphGpGyXpOeUVuS1tz3/2Wq92+JU3VLjd0+1BlGzsNgQo9FVLFIhIp4Xc9elPHRysPDsxilXAYujCERWX5oPF68qua2Bcw/U2VKnWmSaEEQL33L0Jk2kezn2oTW0PSUC4KGWgrpIuEyIi2Vhcdn1CoVCQU9gM2knKi2PPYPdEFE3V2PWkw0Lxt4bBx8Ux4oZ0u0zrXLD07h4F1CUE5tl0Pbw2+VzFTdJGROpQVPFBjTrVzKhVd/5sRM9TVoHZ1ouNB2XrOHoJ391lAuxYJXTP1MBj3Zfa68mlqZaN+/DfWT33rtZSkHBhkgqUqH3j+XgFgoJOLfJ2UcvSA3u9o7jrORvaaDfS57CLZLb1Xe9WHrWl7P+WYSj3CR5KOdvGBdixgI3lAMvpSoRiz/hbZaG9oa+sIMuL6BhE/aGAhnyRVmByWuqmY6ZBIdUG+I0UYjR+/2fEYQ5cn0rnxxPPnHat1z06YxLeef17Vvzz0ov61ab73/oUNXflWknRO1MfRjmOIhWfQcMYwIPPKCKPzd2fDm5DOq0OxYXbdwvc+DgXbm8mhGMGuyUgKGiFz8xgCAaoxE7mS4onOBRcSkFSklUouGecbEOEsSmEaACEU8JuKLgZv3df6QsLCsJbYKer3f75xTIK9CYLRPgg2XxLtYEKEToZcNHF4PBi5psjbeXWMPmF6L/+rFQdj2+wldiZOmGtvolEfjFyzNdnPghfJCeuwh49VyzDtP602p8n+Aza++ws=&lt;/diagram&gt;&lt;/mxfile&gt;" style="background-color: rgb(255, 255, 255);"><defs/><g transform="translate(0.5,0.5)"><path d="M 80 20 L 153.63 20" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 158.88 20 L 151.88 23.5 L 153.63 20 L 151.88 16.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><rect x="0" y="0" width="80" height="40" fill="#ffffff" stroke="#000000" pointer-events="none"/><g transform="translate(3.5,13.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="72" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 74px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">fn main() { .. }</div></div></foreignObject><text x="36" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">fn main() { .. }</text></switch></g><path d="M 240 20 L 260 20 L 260 100 L 313.63 100" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 318.88 100 L 311.88 103.5 L 313.63 100 L 311.88 96.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 240 20 L 313.63 20" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 318.88 20 L 311.88 23.5 L 313.63 20 L 311.88 16.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><rect x="160" y="0" width="80" height="40" fill="#ffffff" stroke="#000000" pointer-events="none"/><g transform="translate(172.5,13.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="54" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 56px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Starscape</div></div></foreignObject><text x="27" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Starscape</text></switch></g><rect x="320" y="80" width="80" height="40" fill="#ffffff" stroke="#000000" pointer-events="none"/><g transform="translate(331.5,93.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="56" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 58px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Vec&lt;Star&gt;</div></div></foreignObject><text x="28" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Vec&amp;lt;Star&amp;gt;</text></switch></g><path d="M 400 20 L 473.63 20" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 478.88 20 L 471.88 23.5 L 473.63 20 L 471.88 16.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 400 20 L 420 20 L 420 100 L 473.63 100" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 478.88 100 L 471.88 103.5 L 473.63 100 L 471.88 96.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><rect x="320" y="0" width="80" height="40" fill="#ffffff" stroke="#000000" pointer-events="none"/><g transform="translate(336.5,13.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="46" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 48px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">NyanCat</div></div></foreignObject><text x="23" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">NyanCat</text></switch></g><rect x="480" y="0" width="90" height="40" fill="#ffffff" stroke="#000000" pointer-events="none"/><g transform="translate(501.5,13.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="46" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 48px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">(i32, i32)</div></div></foreignObject><text x="23" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">(i32, i32)</text></switch></g><rect x="480" y="80" width="90" height="40" fill="#ffffff" stroke="#000000" pointer-events="none"/><g transform="translate(514.5,93.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="20" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 22px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">u64</div></div></foreignObject><text x="10" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">u64</text></switch></g><g transform="translate(96.5,3.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="46" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 46px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">universe</div></div></foreignObject><text x="23" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">universe</text></switch></g><g transform="translate(269.5,3.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="20" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 20px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">.cat</div></div></foreignObject><text x="10" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">.cat</text></switch></g><g transform="translate(274.5,83.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="30" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 30px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">.stars</div></div></foreignObject><text x="15" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">.stars</text></switch></g><g transform="translate(428.5,3.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="22" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 24px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">.pos</div></div></foreignObject><text x="11" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">.pos</text></switch></g><g transform="translate(428.5,83.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="43" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 43px; white-space: nowrap; word-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">.volume</div></div></foreignObject><text x="22" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">.volume</text></switch></g></g></svg>

For example, the `main()` scope owns the `Starscape` via the `universe` let binding.

---


# Assignment moves unless a type is `Copy`

```rust
let cat: NyanCat = unimplemented!(); // somehow make a cat

let cat2: NyanCat = cat;
```

`cat2` now references the memory that `cat2` used to reference, and ownership has moved to `cat2` as well.

Can override move-by-default behaviour by implementing the `Copy` trait for `NyanCat`:

```rust
#[derive(Copy)]
struct NyanCat {
    pos: (i32, i32),
    volume: u64,
}
```

Causes assignment to instead do a bit-by-bit copy of referenced memory, like a faster version of calling `.clone()`.

---

# Borrowing

* You can take a reference to memory without taking ownership

* This is called "borrowing":

```rust
let cat: NyanCat = unimplemented!(); // somehow make a cat

let cat2: &NyanCat = &cat;
```

* Can also take a "mutable borrow":

```rust
let mut cat: NyanCat = unimplemented!(); // somehow make a cat
// `cat` is `mut`, so we can mutate it

let cat2: &mut NyanCat = &mut cat;
// `cat2` is `&mut`, so we can mutate it
```

---

# Borrow checker (borrowck)

Borrowing must always follow 5 simple rules:

1. Can only have one mutable borrow at a time

2. Can have as many immutable borrows as you want

3. Cannot borrow the same data immutably and mutably at the same time

4. Cannot mutate if there is a different borrow active

5. A borrow may not outlive the underlying variable's lifetime

&nbsp;

If you don't follow these rules, code will not compile.

---

class: center, middle

# On to concurrency!

---

# Threads

Native threads, not green threads

```rust
use std::thread;

for i in 0..10 {
  let tx = tx.clone();
  thread::spawn(|| {
    println!("Hi from thread {}", i)
  });
}
```

* Errors normally communicated via the `Result` enum...

* But threads can panic too, which is usually caught at thread boundaries

    * Can also catch within the thread but generally only done for FFI

???

fairly well known that Rust used to have green threads but ripped them out - runtime requirement made them conflict with Rust's systems programming goal

* https://doc.rust-lang.org/book/error-handling.html
* https://doc.rust-lang.org/nomicon/unwinding.html
* https://doc.rust-lang.org/nomicon/exception-safety.html
* https://doc.rust-lang.org/nomicon/poisoning.html
* http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/

---

# Data races

With concurrency comes data races...

.quote[
> "Shared mutable memory is the root of all evil"
]

### Modern languages generally solve by either:

* no *shared* memory: force threads to send messages to each other

* no *mutation* of memory: force threads to take copies of data

???

Channel based approachs like Go and actor systems like Erlang and Akka force threads to send memory to each other

Other languages like Haskell, Scala force your data to be immutable and copied

---

# Rust says: "no *shared mutation* of memory"

Borrowing rules we just covered statically guarantee at compile time that **no thread can mutate data while another thread can access that same data**.

For example,

1. Allocate a `Vec`

2. Set up 2 threads to write to the `Vec`, each from a closure

3. Each thread's closure will borrow* the `Vec`

4. Since each want to muate the `Vec`, we try for an `&mut` reference

5. -> Run afoul of the "1 mutable borrow at a time" rule

&nbsp;

&nbsp;

<sub>
(* We could force the closure to take ownership with `move|| { ... }` syntax but then we run into the "all data must have 1 owner" rule so it's still sound.)
</sub>

???

Rust identifies that neither mutation nor sharing is inherently bad and each approach has its upsides and downsides, so allows using them.. but not together.

Put another way: shared memory XOR mutation of aforementioned memory.

More: https://doc.rust-lang.org/beta/nomicon/races.html

## Aside - move closure

A `move` closure means any referenced variables should have their ownership moved if they can't be copied (rather than take a reference).

But Rust won't let you use that approach to subvert anything either.

---

class: center, middle

# What about data structure thread safety?

Introducing Send & Sync.

???

Sometimes you have data structures that aren't even safe to share across threads, even if the sharing happens very separately from mutation.

---

### Q: Can I send a variable between threads?

A: Only if it implements the **`Send`** trait, which is almost all primitive types and types composed thereof.

But, for example, in SDL, the thread that creates the window must be the one that handles the events. The `SdlWindow` struct would not implement `Send`.

### Q: Can I access a shared variable from another thread?

A: Only if it implements the **`Sync`** trait, which is any type `T` where `&T` is safe to pass between threads without undefined behaviour, which is most types.

But, for example, the `Rc` smart pointer (implements reference counting) does not use atomics to count references & so does not implement `Sync`.<br>
You would use an `Arc` (Atomic Rc) to share a reference count between threads.

???

Only structs which are so-called `Send` can be moved to another thread (i.e. another thread can take ownership). Useful when you're wrapping a library which itself isn't thread safe.

And only structs which implement `Sync` can be accessed from another thread.

Compiler auto implements these traits for all eligible structs, which is most structs.

And if you know better than the compiler, you can opt a struct in or out (requires unsafe code, because it's an escape hatch)

More:

* https://doc.rust-lang.org/book/concurrency.html
* https://doc.rust-lang.org/std/marker/trait.Send.html
* https://doc.rust-lang.org/std/marker/trait.Sync.html
* https://doc.rust-lang.org/nomicon/send-and-sync.html
* https://doc.rust-lang.org/std/sync/atomic/
* http://huonw.github.io/blog/2015/02/some-notes-on-send-and-sync/ (just before 1.0 release)

---

class: center, middle

.quote[
So share everything!

The borrow checker will save you!
]

And if you can't make the borrow checker happy,

then fall back to using locks and message passing.

---

# Send messages via channels

```rust
use std::thread;
use std::sync::mpsc::channel;

// Create a shared channel that can be sent along from many threads
// where tx is the sending half (tx for transmission), and rx is the receiving
// half (rx for receiving).
let (tx, rx) = channel();
for i in 0..10 {
  let tx = tx.clone();
  thread::spawn(move|| { // spawn a thread then send the thread number
    tx.send(i).unwrap(); // returns a Result; unwrap() is quick & dirty handling
  }); // spawn() returns a handle we could (but don't) use to check for panic
}

for _ in 0..10 { // wait for all threads to send their numbers
  let j = rx.recv().unwrap(); // again, dirty dirty error handling
  assert!(0 <= j && j < 10);
}
```

See also `burntsushi`'s `chan` and `chan-signal` libraries for multi-producer multi-consumer channels and signal handling.

???

`move` keyword before the closure's double pipe (`||`) indicates that rather than treat references to variables outside the closure as references, those variables should instead be moved into the closure, such that they're owned by the closure (rather than their original owning context).

As an aside, we could be checking whether or not each thread panics here, but we don't because I have limited space

`chan-signal` is super useful because normally you can't do much while handling signals

More:

* https://static.rust-lang.org/doc/master/std/sync/mpsc/index.html
* https://github.com/BurntSushi/chan
* https://github.com/BurntSushi/chan-signal

---

# "Impossible to use incorrectly" locks

```rust
// (simplification of stdlib mutex - stdlib is more ergonomic)

// create a new mutex
fn mutex<T: Send>(t: T) -> Mutex<T>;

// acquire the lock
fn lock<T: Send>(mutex: &Mutex<T>) -> MutexGuard<T>;

// access the data protected by the lock
fn access<T: Send>(guard: &mut MutexGuard<T>) -> &mut T;


// example usage
fn use_lock(mutex: &Mutex<Vec<i32>>) {
  // acquire the lock, taking ownership of a guard;
  // the lock is held for the rest of the scope
  let mut guard = lock(mutex);

  // access the data by mutably borrowing the guard
  let vec = access(&mut guard);

  // vec has type `&mut Vec<i32>`
  vec.push(3);

  // lock automatically released here, when `guard` is destroyed
}
```

???

In most languages it's easy to hold the wrong lock (or not hold a lock when you should be holding one)

Usually only documentation guards against holding no lock or the wrong lock

so locks get a bad rap, but sometimes you know you need a lock

In Rust, a mutex is conceptually like a container which holds the data that it protects, so it's generic over the type it's protecting

Successfully acquiring the lock gets you a MutexGuard

From the MutexGuard, you can access the data protected by the mutex

But crucially, the resulting T cannot live longer than the MutexGuard (eachg borrow has a lifetime, and the output borrow is assumed to live at most as long as the input-ted data could), and the lock is only released when the guard is destroyed.

So it's not possible to use the lock incorrectly without getting a compiler error, and it's not possible to access the data without holding the lock.

More:
* https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html
* http://softwareengineering.stackexchange.com/questions/317873/how-does-rust-diverge-from-the-concurrency-facilities-of-c

---

class: center, middle

## Locking and message passing is table stakes.

# What else do we have?

---

# Optionally parallel iterators via Rayon

Regular stdlib lazy iterator (compiles to similar code as a for loop):

```rust
let dot_product = vec1.iter() // get an iterator over the 1st vector
    .zip(vec2.iter()) // make pairs of elems out of 1st & 2nd vectors
    .map(|(i, j)| i * j) // make pairs of multiply pairs together
    .sum(); // sum element 
```

Magic *optionally* parallel version from Rayon library, with no loss of safety:

```rust
let dot_product = vec1.par_iter() // now the same thing again, but in parallel!
    .zip(vec2.par_iter())
    .map(|(i, j)| i * j) // .par_iter()s above means this may run in parallel
    .sum(); // this may also run in parallel
```


???

Send & Sync traits keep giving

Let's say you have 2 huge vectors and you want to calculate the dot product of them

You could write a for loop for that, but using the standard library's iterator APIs is less error prone

Once you've written that you can pull in the Rayon library and have the same thing run in parallel via a work stealing thread pool

Here this is obviously thread safe, but the really cool is that even if you were mutating some state already on the stack or the heap, the code wouldn't compile if 

* closures passed to `map()` touch non-threadsafe data structures (because those structures would be non-Sync)
* OR if the vectors contained data that were not safe to pass between threads (the data was non-Send)

---

# Rayon under the hood

`.par_iter()` is a high level wrapper around one basic & simple API:

```rust
// `do_something` and `do_something_else` *may* run in parallel via work stealing
// ... but only if there are free CPU cores at work stealing time!
let (result_a, result_b) = join(|| calc_result_a(), || calc_result_b())
```

1. Before `calc_result_a()` starts running, `calc_result_b` will be put onto a queue

2. If another thread is free, it will steal `calc_result_b` and work on it

3. If `calc_result_a()` finishes and result b isn't done yet, the same thread will calc result b

&nbsp;

**Note:** Do not use for non-CPU bound tasks, like reading from files!

???

Another really neat detail is that this functionality is built on a really simple primitive, which just lets 2 pieces of code optionally run in parallel.

1. Before `calc_result_a()` starts running, `calc_result_b` will be put onto a queue
2. If another thread is free, it will steal `calc_result_b` and work on it
3. If `calc_result_a()` finishes and result b isn't done yet, the same thread will calc result b

Naturally avoids splitting work into too many threads when there's not enough CPU capacity to make use of those threads

Can use this API to implement quick sort in parallel, and rust's type system will actually catch the case where you're operating on overlapping parts of the vector you're sorting

For 1024kb arrays, 4x speedup on 4 core CPU via parallel quicksort, slightly slower than normal for 1k arrays. Most expensive bit of algorithm is putting work onto the queue, but rust's focus on zero cost abstractions keeps this efficient enough.

Possibly faster now because these numbers are from a year ago.

Num of threads in the thread pool is usual equal to num logical cores, so obviously not a good idea to use this for non-CPU bound things.

More info:

* http://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/
* http://smallcultfollowing.com/babysteps/blog/2016/02/19/parallel-iterators-part-1-foundations/
* http://smallcultfollowing.com/babysteps/blog/2016/02/25/parallel-iterators-part-2-producers/
* http://smallcultfollowing.com/babysteps/blog/2016/11/14/parallel-iterators-part-3-consumers/

---

# Futures for non-CPU bound work

* A `Future` (from `futures` crate) is a promise of a value, which may or may not be realised yet

```rust
trait Future {
    type Item; // we get this on successful completion
    type Error; // we get this if the future couldn't complete

    // The only required method, which attempts to complete the future.
    fn poll(&mut self) -> Poll<Self::Item, Self::Error>;

    // Wait for this future to complete (blocks current thread)
    fn wait(self) -> Result<Self::Item, Self::Error> { ... }

    // Transforms the result of the future using the given closure.
    fn map<F, U>(self, f: F) -> Map<Self, F>
        where F: FnOnce(Self::Item) -> U { ... }

    // ... and many, many more provided methods
}
```

* Kind of like green threads (except `Future`s don't have separate stacks) - feels like NodeJS's promises, Scala's futures, etc

???

https://github.com/alexcrichton/futures-rs
https://aturon.github.io/blog/2016/08/11/futures/
https://aturon.github.io/blog/2016/09/07/futures-design/
https://tokio.rs/docs/getting-started/futures/
https://tokio.rs/docs/going-deeper/futures-model/
https://tokio.rs/docs/going-deeper/tasks/

---

# Using futures to time out a computation

```rust
fn check_primality_or_time_out() {
    let pool = CpuPool::new_num_cpus();
    let timer = Timer::default();

    // a future that resolves to Err after a timeout
    let timeout = timer.sleep(Duration::from_millis(750))
        .then(|_| Err(()));

    // a future that resolves to Ok with the primality result
    let prime = pool.spawn_fn(|| {
        Ok(is_prime(BIG_PRIME)) // prime check which might take a while
    });

    // a future that resolves to one of the above values -- whichever
    // completes first!
    let winner = timeout.select(prime).map(|(win, _)| win);

    // now block until we have a winner, then print what happened
    match winner.wait() {
        Ok(true) => println!("Prime"),
        Ok(false) => println!("Not prime"),
        Err(_) => println!("Timed out"),
    }
}
```

???

Example stolen from https://tokio.rs/docs/getting-started/futures/

---

# Futures under the hood

Conceptually, a magical event loop exists under the covers that checks whether the next stage of a future is ready, and runs your code if it is.

In practice, epoll/kqueue is used via the `mio` crate to allow each `Future` implementation to indicate if it is ready:

```rust
trait Future { // remember this?
    // what's this Poll<> business?
    fn poll(&mut self) -> Poll<Self::Item, Self::Error>;
}

type Poll<T, E> = Result<Async<T>, E>;

enum Async<T> {
    Ready(T), // Represents that a value is immediately ready.
    NotReady, // Represents that a value is not ready yet, but may be later.
}
```

In more detail, futures are turned into "tasks" and run by "executors" (e.g. single thread, thread pool, etc).

Futures are readiness-based (not completion-based/using callbacks as e.g. in Scala); gives free cancellation and backpressure.

---

# Sources and Sinks for multiple Futures



---

# `Tokio` is `Future`-based infrastructure



---

class: center, middle

## thanks!

# Questions?
    </textarea>
  </body>
</html>
